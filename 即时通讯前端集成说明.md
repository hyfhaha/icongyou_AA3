## 即时通讯前端集成说明（Conversation + Message 新逻辑）

### 一、概述

本说明文档面向 **前端开发**，解释在引入 `conversation` / 新版 `message` 表之后，**即时通讯（点对点私聊）模块的使用方式**。  
新的后端逻辑要求：**所有消息都必须隶属于一个会话（conversation）记录**，后端在发送消息时会自动创建或复用会话，前端只需要按文档调用 API 即可。

---

### 二、基础约定

- **鉴权方式**
  - 所有接口均需要在请求头中携带 `Authorization: Bearer <token>`（通过登录接口获取的 token）。
  - 多租户信息 `tenant_id` 由服务端在 `req.user` 中注入，前端 **不需要** 在消息接口中手动传入。

- **数据模型概念**
  - **会话（Conversation）**：一对一会话，维度是「当前登录用户 + 对方用户 + 租户」。
  - **消息（Message）**：属于某个会话的聊天记录。
  - **会话 ID（conversation_id）**：
    - 格式：`tenant_minUserId_maxUserId`（例如：`1_10001_10002`）。
    - 前端 **不需要自己计算**，仅用于展示或作为本地 state key。

---

### 三、会话列表接口（对话列表）

#### 1. 接口定义

- **方法**：`GET`  
- **URL**：`/api/messages/conversations`  
- **权限**：已登录用户

#### 2. 功能说明

- 返回 **当前登录用户** 参与的所有会话列表。
- 每条记录对应一个「我 + 某个对方用户」的会话。
- 包含未读消息数量和最后一条消息摘要。

#### 3. 请求示例

```http
GET /api/messages/conversations HTTP/1.1
Authorization: Bearer <token>
```

#### 4. 响应数据结构

```json
{
  "list": [
    {
      "conversationId": "1_10001_10002",
      "partnerId": 10002,
      "partnerName": "张三",
      "partnerRole": "student",
      "lastMessage": "最近这次作业做得不错",
      "lastTime": "2025-12-02T19:00:40.000Z",
      "unreadCount": 3
    }
  ]
}
```

- **字段说明**
  - **conversationId**：会话唯一标识（字符串），前端可作为本地 key 使用。
  - **partnerId**：对方用户 ID，用于进入聊天窗口时的路由参数或状态。
  - **partnerName**：对方显示名称（优先 `nickname`，否则 `username`，若无则为“未知用户”）。
  - **partnerRole**：对方角色（如 `student` / `teacher`），可用于 UI 样式区分。
  - **lastMessage**：最后一条消息内容（后端截断到 1000 字符）。
  - **lastTime**：会话更新时间，一般用于排序和时间展示。
  - **unreadCount**：当前用户在该会话中的未读条数。

#### 5. 前端使用建议

- **会话列表页**
  - 按 `lastTime` 倒序显示（后端已按更新时间排序）。
  - 显示会话头像、对方名称、最后一条消息、时间、未读角标。
- **刷新策略**
  - 可以定时轮询 `GET /api/messages/conversations`，或者结合 WebSocket/长轮询，只用该接口做兜底刷新。

---

### 四、聊天记录接口（与某个用户的消息列表）

#### 1. 接口定义

- **方法**：`GET`  
- **URL**：`/api/messages/with/:userId`  
- **查询参数**：
  - `page`（可选，默认 `1`）
  - `pageSize`（可选，默认 `20`）
- **权限**：已登录用户

> 注意：`:userId` 是 **对方用户 ID**，不是 `conversationId`。  
> 后端会根据「当前用户 + 对方用户 + tenant」自动计算 `conversation_id`。

#### 2. 功能说明

- 获取当前用户与指定用户之间的消息记录。
- 接口被调用时，后端会在事务中自动完成：
  - 清零当前用户在该会话中的未读消息计数。
  - 更新 `read_receipt`，记录当前用户已读到的最后一条消息 ID。

#### 3. 请求示例

```http
GET /api/messages/with/10002?page=1&pageSize=20 HTTP/1.1
Authorization: Bearer <token>
```

#### 4. 响应数据结构

```json
{
  "list": [
    {
      "id": 101,
      "senderId": 10001,
      "receiverId": 10002,
      "fromMe": true,
      "content": "最近这次作业做得不错",
      "createTime": "2025-12-02T19:00:40.000Z",
      "timestamp": 1733137240000
    },
    {
      "id": 102,
      "senderId": 10002,
      "receiverId": 10001,
      "fromMe": false,
      "content": "谢谢老师！",
      "createTime": "2025-12-02T19:01:10.000Z",
      "timestamp": 1733137270000
    }
  ],
  "page": 1,
  "pageSize": 20,
  "total": 2
}
```

- **字段说明**
  - **list**：消息数组，已按时间从旧到新排序（后端查询时为倒序，再在返回前 `reverse()` 一次）。
  - **id**：消息主键 `msg_id`。
  - **senderId / receiverId**：发送者 / 接收者用户 ID。
  - **fromMe**：布尔值，是否是当前登录用户发送的消息。
  - **content**：消息文本内容。
  - **createTime**：数据库记录的创建时间。
  - **timestamp**：毫秒级时间戳，用于前端精确排序或本地时间展示。
  - **page / pageSize / total**：分页信息。

#### 5. 前端使用建议

- **打开聊天窗口时**
  - 路由示例：`/im/:userId`，其中 `:userId` 为对方用户 ID。
  - 进入页面后调用 `GET /api/messages/with/:userId?page=1&pageSize=20`。
  - 使用返回的 `list` 渲染消息气泡：
    - 使用 `fromMe` 区分左右对齐。
    - 使用 `timestamp` / `createTime` 做时间分组或展示标签。
  - 请求成功后，该会话的未读数会自动清零。

- **下拉加载历史消息**
  - 当用户滚动到顶部且 `page < totalPage` 时，调用下一页：
    - `GET /api/messages/with/:userId?page=page+1&pageSize=20`。
  - 将新返回的消息数组插入现有消息数组的 **前面**。

- **已读逻辑**
  - 不需要额外的“标记已读”接口。
  - 只要调用一次 `GET /api/messages/with/:userId`，后端会自动重置未读数并更新已读回执。

---

### 五、发送消息接口（自动创建/复用会话）

#### 1. 接口定义

- **方法**：`POST`  
- **URL**：`/api/messages`  
- **请求体（JSON）**：

```json
{
  "receiverId": 10002,
  "content": "最近这次作业做得不错"
}
```

- **权限**：已登录用户

#### 2. 功能说明（新逻辑重点）

- **所有消息必须隶属于一个会话（conversation）**，但这一过程由后端自动处理：
  1. 后端根据「当前用户 + `receiverId` + `tenant_id`」计算 `conversation_id`。
  2. 在同一事务中：
     - **先查找或创建对应的 `conversation` 记录**（如果不存在则新建）。
     - 再在该会话下插入一条 `message` 记录。
     - 更新会话的 `last_msg_id` / `last_msg_content` / `last_msg_time` 以及对方的未读计数。

- 前端只需传入 `receiverId` 和 `content`，**不需要** 手动创建会话，也 **不需要** 传 `conversation_id`。

#### 3. 响应数据结构

```json
{
  "id": 101,
  "senderId": 10001,
  "receiverId": 10002,
  "content": "最近这次作业做得不错",
  "isRead": false,
  "createTime": "2025-12-02T19:00:40.000Z"
}
```

- **字段说明**
  - **id**：消息 ID。
  - **senderId / receiverId / content / createTime**：与存储一致。
  - **isRead**：当前返回值恒为 `false`（对方尚未阅读），后续如果需要“已读”状态，可以在增加专门接口后再扩展。

#### 4. 前端使用建议

- **发送消息交互**
  1. 从当前聊天上下文拿到 `receiverId`（聊天对象 ID）。
  2. 从输入框拿到 `content`，前端可先校验非空。
  3. 调用 `POST /api/messages`。
  4. 若成功，将返回的消息数据追加到当前消息数组末尾，并清空输入框。

- **错误处理**
  - 若返回 `400` 且提示 `receiverId 和 content 为必填`，检查参数完整性。
  - 若返回 `400` 且提示 `不能给自己发送消息`，前端可在 UI 上禁止对自己发消息。
  - 若返回 `404` 且提示 `接收方用户不存在`，可以弹窗提示并返回会话列表页。

---

### 六、典型前端流程示例

#### 1. 进入消息模块首页（会话列表页）

1. 页面加载时调用 `GET /api/messages/conversations`。
2. 渲染会话列表，显示：
   - 头像（由 `partnerId` / `partnerRole` 推导）。
   - 对方名称 `partnerName`。
   - 最后一条消息文案 `lastMessage`。
   - 时间 `lastTime`（前端格式化）。
   - 未读角标 `unreadCount`。

#### 2. 打开与某人的聊天窗口

1. 用户点击会话列表某一项（携带 `partnerId`，可选携带 `conversationId`）。
2. 路由示例：`/im/10002`。
3. 进入页面后调用 `GET /api/messages/with/10002?page=1&pageSize=20`。
4. 将返回的 `list` 渲染为消息气泡，使用 `fromMe` 控制左右对齐。
5. 此时该会话的未读数已在后端清零。

#### 3. 在聊天窗口中发送消息

1. 用户输入消息文本。
2. 调用 `POST /api/messages`，`receiverId` 为当前聊天对象 ID。
3. 成功后将返回的消息对象直接追加到列表末尾，实现即时反馈。

#### 4. 下拉加载历史消息

1. 当消息列表滚动到顶部时，判断是否还有上一页（通过 `page` 与 `total` 推断）。
2. 若有，调用 `GET /api/messages/with/:userId?page=page+1&pageSize=20`。
3. 将返回的历史消息插入现有消息数组 **前面**。

---

### 七、与旧逻辑的差异与注意事项

- **不再直接使用旧的 `messages` 表及相关接口**，新的表名为单数 `message`，字段结构已经重构。
- **前端不负责会话创建**：
  - 不需要、也不建议前端手动创建 `conversation` 记录。
  - 发送消息时只用 `receiverId` + `content`，后端会自动：
    - 生成或复用 `conversation_id`；
    - 维护 `conversation` 表的最后一条消息和未读数。
- **不需要也不应该前端手动构造 `conversation_id`**：
  - 后端内部采用 `tenant_minUserId_maxUserId` 规则；
  - 前端只在展示或本地缓存 key 时读取该字段即可。
- “必须先有会话再有消息”的约束已经由后端事务保证，前端只需要按本说明调用以下三个接口完成 IM 功能：
  - 获取会话列表：`GET /api/messages/conversations`
  - 获取与某用户的消息列表：`GET /api/messages/with/:userId`
  - 发送消息：`POST /api/messages`

---

### 八、典型时序说明（前端视角 + 后端内部步骤）

#### 1. 打开与某个用户的聊天窗口（获取对话记录）

以当前用户 ID 为 `meId`，对方用户 ID 为 `otherId` 为例，完整时序如下：

1. **前端**
   - 路由跳转到聊天页面，例如 `/im/:otherId`。
   - 组件挂载后调用：`GET /api/messages/with/:otherId?page=1&pageSize=20`。
2. **后端（接收请求）**
   - 从 token 中解析出 `meId`、`tenant_id`。
   - 从路径参数中读取 `otherId`。
3. **后端（计算会话 ID）**
   - 调用 `getConversationId(meId, otherId, tenantId)`，生成 `conversation_id = tenant_minId_maxId`。
4. **后端（查询消息列表）**
   - 在 `message` 表中按条件查询：
     - `conversation_id = 上一步计算结果`；
     - `status = 1`（正常消息）；
   - 按 `timestamp_ms DESC` 排序并分页查询。
5. **后端（重置未读 + 写入已读回执）**
   - 在 `conversation` 表中查找到对应会话：`conversation_id + tenant_id`。
   - 判断当前用户是 `user_a` 还是 `user_b`，将对应的 `unread_a` 或 `unread_b` 重置为 `0`。
   - 在 `read_receipt` 表中：
     - 查询当前用户在该会话下是否已有回执记录；
     - 若有且 `last_read_msg_id < 当前最新消息 msg_id`，则更新为最新 `msg_id`；
     - 若没有，则插入一条新的回执记录（`conversation_id + user_id + tenant_id + last_read_msg_id`）。
6. **后端（构造响应）**
   - 将查到的消息数组反转（从倒序变为正序：时间从旧到新）。
   - 映射为前端字段格式：`{ id, senderId, receiverId, fromMe, content, createTime, timestamp }`。
   - 返回：`{ list, page, pageSize, total }`。
7. **前端（渲染）**
   - 使用返回的 `list` 渲染消息气泡，`fromMe === true` 的消息靠右显示。
   - 会话列表页面下次刷新时，会看到该会话的未读数已经变为 `0`。

#### 2. 在聊天窗口中发送一条消息

完整时序如下：

1. **前端**
   - 用户在输入框中填写内容，点击“发送”。
   - 调用：`POST /api/messages`，请求体 `{ receiverId: otherId, content: '消息内容' }`。
2. **后端（参数校验）**
   - 从 token 中解析 `meId`。
   - 校验 `receiverId` 与 `content` 是否存在且合法，禁止给自己发消息。
   - 校验接收方用户是否存在（查 `user` 表）。
3. **后端（计算会话 ID 并确保会话存在）**
   - 根据 `meId + receiverId + tenant_id` 计算 `conversation_id`。
   - 在 `conversation` 表中按 `conversation_id + tenant_id` 查询：
     - 若存在会话，则直接复用；
     - 若不存在，则创建一条新会话记录（写入 `conversation_id`、`user_a`、`user_b`、`tenant_id` 等字段，初始未读数为 0）。
4. **后端（写入消息记录）**
   - 在 `message` 表中插入一条新记录：
     - 写入 `conversation_id`、`sender_id`、`receiver_id`、`content`、`content_type`、`status`、`timestamp_ms`、`tenant_id` 等字段。
5. **后端（更新会话的最后一条消息 + 未读数）**
   - 判断发送方是 `user_a` 还是 `user_b`。
   - 在 `conversation` 表中更新：
     - `last_msg_id = 新插入消息的 msg_id`；
     - `last_msg_content = 截断后的消息内容（最多 1000 字符）`；
     - `last_msg_time = 消息的 timestamp_ms`；
     - `update_time = 当前时间`；
     - 将接收方对应的未读计数 `unread_a` 或 `unread_b` 加 1。
6. **后端（返回响应）**
   - 返回新消息的基本信息（`id, senderId, receiverId, content, isRead=false, createTime`）。
7. **前端（更新 UI）**
   - 将返回的这条消息立即追加到当前消息列表末尾。
   - 清空输入框，保持滚动条在底部，实现“即时发送”的体验。

